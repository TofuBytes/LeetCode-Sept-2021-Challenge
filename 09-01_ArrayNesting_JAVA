/* Array Nesting
You are given an integer array nums of length n where nums is a permutation of the numbers in the range [0, n - 1].

You should build a set s[k] = {nums[k], nums[nums[k]], nums[nums[nums[k]]], ... } subjected to the following rule:

The first element in s[k] starts with the selection of the element nums[k] of index = k.
The next element in s[k] should be nums[nums[k]], and then nums[nums[nums[k]]], and so on.
We stop adding right before a duplicate element occurs in s[k].
Return the longest length of a set s[k].
*/
You are given an integer array nums of length n where nums is a permutation of the numbers in the range [0, n - 1].

You should build a set s[k] = {nums[k], nums[nums[k]], nums[nums[nums[k]]], ... } subjected to the following rule:

The first element in s[k] starts with the selection of the element nums[k] of index = k.
The next element in s[k] should be nums[nums[k]], and then nums[nums[nums[k]]], and so on.
We stop adding right before a duplicate element occurs in s[k].
Return the longest length of a set s[k].
class Solution {
    public int arrayNesting(int[] nums) {
        int most = 0;
        //creat set to keep track of accesed values
        HashSet<Integer> set = new HashSet<Integer>();
        
        //loop through nums
        for(int x = 0; x < nums.length; x++){
            int val = nums[x]; 
            int curr = 0;
            boolean same = false;
            
            //loop through set and ignore values that were accessed already
            while(!same){
                if(set.contains(val)){
                   same = true;;
                }
                else{
                    set.add(val);
                    val = nums[val];
                    curr++;
                }
            }
            //update length
            most = Math.max(most,curr);
        }
        return most; 
    }
}
